\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{pgfplots}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}

\lstset{
    language=C++,
	numbers=left,
	basicstyle=\footnotesize,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}, 
	tabsize=2,
	title=\lstname,       
}

\begin{document}

\begin{titlepage}
  \begin{center}
    \large
    МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ\\ РОССИЙСКОЙ ФЕДЕРАЦИИ
     
    \textbf{Федеральное государственное автономное образовательное учреждение высшего образования}
    \vspace{0.5cm}
 
    «Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского» (ННГУ)
    \vspace{0.25cm}
     
    Институт информационных технологий, математики и механики
     
    Направление подготовки: «Фундаментальная информатика и информационные технологии»
    \vspace{0.75cm}
     
     
    ОТЧЕТ\\
    по лабораторной работе
    \vfill
      
    {\LARGE Поиск кратчайших путей из одной вершины (алгоритм Мура).}
  \bigskip
     
\end{center}
\vfill
 
\newlength{\ML}
\settowidth{\ML}{«\underline{\hspace{0.7cm}}» \underline{\hspace{2cm}}}
\hfill\begin{minipage}{0.4\textwidth}
  Выполнил:\\
  студент группы 381808-2\\
  \underline{\hspace{\ML}} С.\,И.~Юрин\\
  «\underline{\hspace{0.7cm}}» \underline{\hspace{2cm}} 2020 г.
\end{minipage}%
\bigskip
 
\hfill\begin{minipage}{0.4\textwidth}
  Проверил:\\
  доцент кафедры МОСТ, \\
  кандидат технических наук \\
  \underline{\hspace{\ML}} А.\,В.~Сысоев\\
  «\underline{\hspace{0.7cm}}» \underline{\hspace{2cm}} 2020 г.
\end{minipage}%
\vfill
 
\begin{center}
  Нижний Новгород\\
  2020
\end{center}
\end{titlepage}

\newpage

\section*{Введение}

Задача о кратчайшем пути — задача поиска самого короткого пути (цепи) между двумя точками (вершинами)
 на графе, в которой минимизируется сумма весов рёбер, составляющих путь.
\par

Задача о кратчайшем пути является одной из важнейших классических задач теории графов. Сегодня известно множество алгоритмов для её решения.
\par

Одним из таких алгоритмов является алгоритм Мура, также известный как алгоритм Беллмана - Мура, также известный как алгоритм Беллмана - Форда.
\par

В отличие от известного алгоритма Дейкстры, алгоритм Мура допускает рёбра с отрицательным весом, поэтому является более универсальным.

\newpage

\section{Постановка задачи}

\begin{enumerate}
 \item Реализовать последовательную версию алгоритма;
 \item Реализовать параллельную версию алгоритма;
 \item Написать тесты, сравнивающие результаты работы алгоритмов при различных входных данных;
 \item Сравнить скорость работы параллельной и последовательной версий алгоритма.
\end{enumerate}

\newpage

\section{Схема распараллеливания}

Распараллеливание применяется к этапу алгоритма, на котором происходит перерасчет меток вершин.
Воспользоваться преимуществом нескольких процессов можно, разделив между ними множетсво соседних вершин,
для которых пересчитываются метки на каждом шаге. Важно, что деление происходит именно на каждой итерации,
потому что если мы применим разбиение только для первой, то выигрыша мы не получим.

\newpage

\section{Алгоритм реализации}
\subsection{Последовательная версия}

\begin{enumerate}
 \item Вершину, из которой ведется поиск, обозначим $x_{s}$;
 \item Заполняем в массиве меток d все метки всех вершин кроме начальной плюс бесконечностями, а метку начальной - нулем;
 \item Записываем в очередь начальую вершину;
 \item Цикл пересчета меток;
	\begin{enumerate}
	 \item Удаляем из очереди вершину $y$, находящуюся в самом начале очереди, она считается текущей;
	 \item Для каждой вершины $x_{i}$, непосредственно достижимой из текущей, корректируем ее метку по формуле;
		$x_{12} d(x_{i})=min\{d_{стар}(x_{i}), d(y)+l(y,x)\}$, где $l(y,x)$ - расстояние от $x$ до $y$;
	 \item Если получившаяся метка удовлетворяет условию $d(x_{i}) < d_{стар}(x_{i})$, то корректируем очередь вершин,
		если не удовлетворяет, то продолжаем перебор вершин и изменение меток;
	 \item Корректировка очереди выполняется по следующему правилу.
		Если вершина $x_{i}$ не была ранее в очереди и не находится в ней в данный момент, то ставим
		ее в конец очереди; если же $x_{i}$ уже была когда-нибудь ранее в очереди или
		находится там в настоящий момент, то переставляем ее в начало очереди;
	 \item Если множество вершин в очереди не пусто - продолжаем цикл; иначе все минимальные расстояния найдены - выходим из цикла;
	\end{enumerate}
 \item Восстанавливаем кратчайший путь. Среди вершин с постоянными метками, непосредственно предшествующих $y$,
	находим вершину $x_{i}$, удовлетворяющую соотношению: $d(y)=d(x_{i})+l(x_{i},y)$. Включаем дугу $(x_{i}, y)$ в искомый путь и полагаем $y=x_{i}$;
 \item Если $y=x_{s}$, то кратчайший найден путь. Если $y!=x_{s}$, то возвращаемся к предыдущему шагу.
\end{enumerate}

\subsection{Параллельная версия}
\begin{enumerate}
 \item В отличие от последовательного метода в параллельном заведем две очереди $q\_start$ и $q\_end$.
	Это понадобиться нам для сбора данных с процессов в нулевой;
 \item Вершину, из которой ведется поиск, обозначим $x_{s}$;
 \item Заполняем в массиве меток $d$ все метки всех вершин кроме начальной плюс бесконечностями, а метку начальной - нулем;
 \item Записываем в очередь $q\_start$ начальую вершину;
 \item Цикл пересчета меток;
	\begin{enumerate}
	 \item Удаляем из очереди $q\_start$ вершину $y$, находящуюся в самом начале очереди, она считается текущей.
		Если $q\_start$ пустая, то удаляем начальную вершину из $q\_end$;
	 \item Рассылаем всем процессам из нулевого индекс текущей вершины и метку текущей вешины;
 	 \item Рассылаем количество обрабатываемых вершин для каждого процесса;
 	 \item Рассылаем индексы обрабатываемых вершин для каждого процесса;
 	 \item Рассылаем текущие значения меток для обрабатываемых вершин;
	 \item Для каждой вершины $x_{i}$, непосредственно достижимой из текущей, корректируем ее метку по формуле;
		$x_{12} d(x_{i})=min\{d_{стар}(x_{i}), d(y)+l(y,x)\}$, где $l(y,x)$ - расстояние от $x$ до $y$;
	 \item Если получившаяся метка удовлетворяет условию $d(x_{i}) < d_{стар}(x_{i})$, то корректируем очередь вершин,
		если не удовлетворяет, то продолжаем перебор вершин и изменение меток;
	 \item Корректировка очереди выполняется по следующему правилу.
		Если вершина $x_{i}$ не была ранее в очереди и не находится в ней в данный момент, то ставим
		ее в конец очереди ($q\_end$); если же $x_{i}$ уже была когда-нибудь ранее в очереди или
		находится там в настоящий момент, то переставляем ее в начало очереди ($q_start$);
	 \item Собираем marks с каждого процесса в нулевом;
	 \item Собираем данные из $q\_start$ и $q\_end$ с каждого процесса в нулевом;
	 \item Если множество вершин в очереди $q\_start$ и в очереди $q\_end$ не пусто - продолжаем цикл; иначе все минимальные расстояния найдены - выходим из цикла;
	\end{enumerate}
 \item Восстанавливаем кратчайший путь. Среди вершин с постоянными метками, непосредственно предшествующих $y$,
	находим вершину $x_{i}$, удовлетворяющую соотношению: $d(y)=d(x_{i})+l(x_{i},y)$. Включаем дугу $(x_{i}, y)$ в искомый путь и полагаем $y=x_{i}$;
 \item Если $y=x_{s}$, то кратчайший найден путь. Если $y!=x_{s}$, то возвращаемся к предыдущему шагу.
\end{enumerate}

\newpage

\section{Результаты экспериментов}

Эксперименты проводились на компьютере с характеристиками
\begin{itemize}
 \item Процессор Intel(R) Core(TM) i3-6006U CPU @ 2.00GHz 2.00 GHz;
 \item OC Windows 10;
 \item Оперативная память 4 GB ОЗУ.
\end{itemize}
\par

Все вычисления проводятся для матрица весов размером 100 на 100 элементов.
\par

Ниже представлены две таблицы - для сравнения времени работы функции целиком (от момента входа в функцию до момента выхода из нее)
и отдельно время работы части алгоритма с пересчетом меток.
\par

\begin{table}[h]
    \begin{tabular}{ | p{4cm} | p{4cm} | p{4cm} | p{4cm} | }
    \hline
    Количество \par процессов & Последовательная реализация, сек & Параллельная \par реализация, сек\\ \hline
    1    &0.1987  & 0.0835  \\ \hline
    2    &0.1373  & 0.0523  \\ \hline
    3    &0.1535  & 0.0879  \\ \hline
    4    &0.1957  & 0.1881  \\ \hline
    5    &0.2329  & 2.3750  \\ \hline
    6    &0.1491  & 3.9608  \\ \hline
    7    &0.1007  & 5.3354  \\ \hline
    8    &0.1195  & 8.7165  \\ \hline
    \end{tabular}
    \caption{Время работы функций целиком (от момента входа в функцию до момента выхода из нее)}
\end{table}

\begin{table}[h]
    \begin{tabular}{ | p{4cm} | p{4cm} | p{4cm} | p{4cm} | }
    \hline
    Количество \par процессов & Последовательная реализация, сек & Параллельная \par реализация, сек\\ \hline
    1    &0.1472  & 0.0062  \\ \hline
    2    &0.1650  & 0.0082  \\ \hline
    3    &0.2202  & 0.0042   \\ \hline
    4    &0.1404  & 0.0064  \\ \hline
    5    &0.2064  & 0.0045  \\ \hline
    6    &0.1989  & 0.0037  \\ \hline
    7    &0.1847  & 0.0045  \\ \hline
    8    &0.1423  & 0.0036  \\ \hline
    \end{tabular}
    \caption{Отдельно время работы части алгоритма с пересчетом меток}
\end{table}


\newpage

\section{Заключение}

По результатам экспериментов все тесты на сравнение возвращаемых значений (длин кратчайших путей и самих траекторий путей)
	параллельной и последовательной функций проходят успешно.
\par

С измерением времени дело обстоит иначе. Как видим из первой таблицы с увеличением количества процессов - увеличивается время работы функции.
Это происходит из-за большого поличества пересылок. Для доказательства этого факта - вторая таблица измеряет время работы функции внутри самой функции,
то есть только соммарное время выполнения итераций цикла пересчета меток (без передач сообщений). Как видим из второй таблицы параллельная 
реализация все же выигрывает у последовательной, а также улучшает свой результат с увеличением количества используемых процессов.


\begin{thebibliography}{1}
\bibitem{Evstigeev}Итеративные алгоритмы глобального анализа графов. Пути и покрытия 
\bibitem{Bellman}R. Bellman: On a Routing Problem // Quarterly of Applied Mathematics. 1958. Vol 16, No. 1. C. 87-90, 1958.
\end{thebibliography}

\end{document}
